options {
    STATIC = false;
}

PARSER_BEGIN(JCCMiniJavaParser)

package minijava.parser.jcc;

import minijava.ast.*;

public class JCCMiniJavaParser {}

PARSER_END(JCCMiniJavaParser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   < "//" (~["\n","\r"])*  > //("\n" | "\r" | "\r\n") We dont want to force single line comments to end with new lines, because then a comment at the end of the file may fail to parse.
|   < "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

// keywords
TOKEN : {
    < BOOLEAN: "boolean" >
|   < CLASS: "class" >
|   < ELSE: "else" >
|   < EXTENDS: "extends" >
|   < FALSE: "false" >
|   < IF: "if" >
|   < INT: "int" >
|   < MAIN: "main" >
|   < NEW: "new" >
|   < NULL: "null" >
|   < PRINT: "System.out.println" >
|   < PUBLIC: "public" >
|   < RETURN: "return" >
|   < STATIC: "static" >
|   < STRING: "String" > // any problem with this being a keyword?
|   < THIS: "this" >
|   < TRUE: "true" >
|   < VOID: "void" >
|   < WHILE: "while" >
}

// identifiers
TOKEN : {
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")* >
|   < INT_LITERAL: "0" | (["1"-"9"] (<DIGIT>)*) >
|   < LETTER: ["a"-"z"] | ["A"-"Z"] >
|   < DIGIT: ["0"-"9"] >
}

// misc
TOKEN : {
    < LPAREN: "(" >
|   < RPAREN: ")" >
|   < LBRACK: "[" >
|   < RBRACK: "]" >
|   < LBRACE: "{" >
|   < RBRACE: "}" >
|   < ADD: "+" >
|   < AND: "&&" >
|   < ASSIGN: "=" >
|   < BANG: "!" >
|   < COMMA: "," >
|   < DOT: "." >
|   < LTHAN: "<" >
|   < MINUS: "-" >
|   < MULT: "*" >
|   < SEMICOLON: ";" >
}

Program Program() : { }
{
    MainClass() ( ClassDeclaration() )* <EOF>
    { return null; }
}

void MainClass() : { }
{
    <CLASS> <IDENTIFIER> <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN>
        <STRING> <LBRACK> <RBRACK> <IDENTIFIER> <RPAREN> <LBRACE>
            Statement()
        <RBRACE>
    <RBRACE>
}

void ClassDeclaration() : { }
{
    <CLASS> <IDENTIFIER> ( <EXTENDS> <IDENTIFIER> )? <LBRACE>
        ( VarDeclaration() | MethodDeclaration() )*
    <RBRACE>
}

void VarDeclaration() : { }
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : { }
{

    <PUBLIC> Type() <IDENTIFIER> <LPAREN> FormalList() <RPAREN> <LBRACE>
        ( LOOKAHEAD(2) VarDeclaration() | Statement() )*
        <RETURN> Expression() <SEMICOLON>
    <RBRACE>
}

void FormalList() : { }
{
    ( Type() <IDENTIFIER> ( <COMMA> Type() <IDENTIFIER> )* )?
}

void Type() : { }
{
 LOOKAHEAD(2) //Explanation: these lookahead statements can sometimes be used to resolve choice conflicts, but they are tricky.
 //I just dropped them in everywhere there was a conflict, until it compiled. But they may not lead to the grammar behaviour
 //we want in the tests. So we may have to remove them later. See:  https://javacc.dev.java.net/doc/lookahead.html
 //Basically, they mean that for the next choice, this is an LL(2) parser, instead of an LL(1). We can also do this globally,
 //but it is less efficient.
    ( <INT> <LBRACK> <RBRACK> )
|   <BOOLEAN>
|   <INT>
|   <STRING>
|   <IDENTIFIER>
}

void Statement() : { }
{
    <LBRACE> ( Statement() )* <RBRACE>
|   ( <IF> <LPAREN> Expression() <RPAREN>
        Statement()
      <ELSE>
        Statement() )
|   ( <WHILE> <LPAREN> Expression() <RPAREN>
        Statement() )
|   ( <PRINT> <LPAREN> Expression() <RPAREN> <SEMICOLON> )
|   ( <IDENTIFIER> ( <LBRACK> Expression() <RBRACK> )?
    <ASSIGN> Expression() <SEMICOLON> )
}



void rightExpression():{}
{
    ( ( <AND> | <LTHAN> | <ADD> | <MINUS> | <MULT> ) Expression() )
|   ( <LBRACK> Expression() <RBRACK> )
|   ( <DOT>  dotStatement()) //left factored
}

void dotStatement():{}
{
 LOOKAHEAD(2)
	(<IDENTIFIER>) //so we have a problem here. The grammaer specifies the string literal "length" here. 
	//In fact, in java, this should be any valid identifier, because it is just referencing a public field. 
	//and identifiers are allowed to be called "length", so we can't match length as a non-identifier token... not sure what to do.
	
	| (<IDENTIFIER> <LPAREN>  (Expression() ( <COMMA> Expression() )* )? <RPAREN> ) //this pattern wont match the first argument correctly
}
void Expression() : { }
{


 (  ( <NEW> newExpression()) //left factored
|   ( <BANG> Expression() )
|   ( <LPAREN> Expression() <RPAREN> )
|   <INT_LITERAL>
|   <TRUE>
|   <FALSE>
|   <IDENTIFIER>
|   <THIS> )
(  LOOKAHEAD(2) rightExpression())? 

}

void newExpression() : {}
{
	(<INT><LBRACK> Expression() <RBRACK> )
	| ( <IDENTIFIER> <LPAREN> <RPAREN>)
}
