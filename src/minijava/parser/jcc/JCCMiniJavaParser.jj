options {
    STATIC = false;
}

PARSER_BEGIN(JCCMiniJavaParser)

package minijava.parser.jcc;

import minijava.ast.*;
import java.util.ArrayList;
public class JCCMiniJavaParser {}

PARSER_END(JCCMiniJavaParser)

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   < "//" (~["\n","\r"])*  > //("\n" | "\r" | "\r\n") We dont want to force single line comments to end with new lines, because then a comment at the end of the file may fail to parse.
|   < "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/" >
}

// keywords
TOKEN : {
    < BOOLEAN: "boolean" >
|   < CLASS: "class" >
|   < ELSE: "else" >
|   < EXTENDS: "extends" >
|   < FALSE: "false" >
|   < IF: "if" >
|   < INT: "int" >
|   < MAIN: "main" >
|   < NEW: "new" >
|   < NULL: "null" >
|   < PRINT: "System.out.println" >
|   < PUBLIC: "public" >
|   < RETURN: "return" >
|   < STATIC: "static" >
|   < STRING: "String" > // any problem with this being a keyword?
|   < THIS: "this" >
|   < TRUE: "true" >
|   < VOID: "void" >
|   < WHILE: "while" >
|   < LENGTH: "length" >
}

// identifiers
TOKEN : {
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>|"_")* >
|   < INT_LITERAL: "0" | (["1"-"9"] (<DIGIT>)*) >
|   < LETTER: ["a"-"z"] | ["A"-"Z"] >
|   < DIGIT: ["0"-"9"] >
}

// misc
TOKEN : {
    < LPAREN: "(" >
|   < RPAREN: ")" >
|   < LBRACK: "[" >
|   < RBRACK: "]" >
|   < LBRACE: "{" >
|   < RBRACE: "}" >
|   < ADD: "+" >
|   < AND: "&&" >
|   < ASSIGN: "=" >
|   < BANG: "!" >
|   < COMMA: "," >
|   < DOT: "." >
|   < LTHAN: "<" >
|   < MINUS: "-" >
|   < MULT: "*" >
|   < SEMICOLON: ";" >
}

Program Program() : {MainClass mainClass;ClassDecl curClass; ArrayList<ClassDecl> classes = new ArrayList<ClassDecl>();}
{
{ System.setProperty("line.separator","\n");}//well, this is a hack if there ever was one. On windows boxes, the newlines produced
//by pretty printer must be unix style.
    mainClass = MainClass() (    
     curClass = ClassDeclaration() 
    {classes.add(curClass);}
    )* <EOF>
    { return new Program(mainClass,new NodeList<ClassDecl>(classes)); }
}

MainClass MainClass() : {Token className;Token argName;Statement statement; }
{
    <CLASS> (className = <IDENTIFIER>) <LBRACE>
        <PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN>
        <STRING> <LBRACK> <RBRACK> (argName=<IDENTIFIER>) <RPAREN> <LBRACE>
           (statement = Statement())
        <RBRACE>
    <RBRACE>
    
    {return new MainClass(className.image,argName.image,statement);}
}

ClassDecl ClassDeclaration() : {Token id; Token exts = null;ArrayList<VarDecl> vars = new ArrayList<VarDecl>(); 
ArrayList<MethodDecl> methods = new ArrayList<MethodDecl>();}
{
    <CLASS> id=<IDENTIFIER> ( <EXTENDS> (exts= <IDENTIFIER>) )? <LBRACE>
        ( ({VarDecl v=null;} v=VarDeclaration(VarDecl.Kind.FIELD) {vars.add(v);}) 
        | ({MethodDecl d=null;} d=MethodDeclaration(){methods.add(d);}) )*
    <RBRACE>
    
    {return new ClassDecl(id.image, (exts==null?"Object":exts.image),vars,methods);}
}

VarDecl VarDeclaration(VarDecl.Kind kind) : {Type t;Token id; }
{
   t= Type() id=<IDENTIFIER> <SEMICOLON>
   {return new VarDecl(kind,t,id.image);}
}

MethodDecl MethodDeclaration() :  {Type t;Token id;NodeList<VarDecl> args;ArrayList<Statement> body = new ArrayList<Statement>();ArrayList<VarDecl> vars = new ArrayList<VarDecl>() ;}
{
    <PUBLIC> t=Type() id= <IDENTIFIER> <LPAREN> args=FormalList() <RPAREN> <LBRACE>        
        (LOOKAHEAD(2) 
               ({VarDecl v;} v= VarDeclaration(VarDecl.Kind.LOCAL) {vars.add(v);})//This doesn't quite match the specification
             | ( {Statement stm;}  stm = Statement() {body.add(stm);})

         )*
        <RETURN> {Expression rtn;}(rtn =Expression()) <SEMICOLON>
    <RBRACE>
    
    {return new MethodDecl(t,id.image,args,new NodeList<VarDecl>(vars),new NodeList(body),rtn);}
}

NodeList<VarDecl> FormalList() : {Type t; Token id; ArrayList<VarDecl> vars = new ArrayList<VarDecl>(); }
{
    ( t=Type() id=<IDENTIFIER> {vars.add(new VarDecl(VarDecl.Kind.FORMAL,t,id.image));}
     ( <COMMA> t=Type() id=<IDENTIFIER> {vars.add(new VarDecl(VarDecl.Kind.FORMAL,t,id.image));})* )?
    {return new NodeList<VarDecl>(vars);}
}

Type Type() : { }
{
    ( <INT> (<LBRACK> <RBRACK> {return new IntArrayType();})? {return new IntegerType();})
|  ( <BOOLEAN> {return new BooleanType();})
| (  <STRING>{return new ObjectType("String");})//is it neccesary to split these two types?
|  ({Token id;} id= <IDENTIFIER>{return new ObjectType(id.image);})
}

Statement Statement() : {Statement stm;Statement stmLocal; Expression exp; Expression tst; }
{
  (//A block of statements
  {ArrayList<Statement> stms = new ArrayList<Statement>();}  
    <LBRACE> ((stmLocal= Statement()) {stms.add(stmLocal);})* <RBRACE>
  {  return new Block(new NodeList<Statement>(stms));}
  )
|   ({Statement thn; Statement els;} <IF> <LPAREN> (tst = Expression()) <RPAREN>
       (thn =  Statement())
      <ELSE>
       (els= Statement())        
       {return new If(tst,thn,els);}
       )
|   ({ Statement body;} <WHILE> <LPAREN> (tst =  Expression()) <RPAREN>
       (body = Statement()) {return new While(tst,body);})
|   ( <PRINT> <LPAREN> (exp = Expression()) <RPAREN> <SEMICOLON> {return new Print(exp);})
|   ({Token id; Expression index = null; Expression assign;}(id = <IDENTIFIER> )( <LBRACK> (index = Expression()) <RBRACK> )?
    <ASSIGN> (assign = Expression()) <SEMICOLON> 
    
    {if(index!=null)
       return new ArrayAssign(id.image,index,assign);
    else
         return new Assign(id.image,assign);
    }
     )
    
}

Expression Expression() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }

{	 
	    (exp =LThanTerm() ) (  <AND>  cur = Expression()

     {exp = new And(exp,cur);})*
     
      { return exp;}
}

Expression LThanTerm() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{     

	 (exp =MinusTerm() ) (  <LTHAN>  cur = Expression()

     {exp = new LessThan(exp,cur);})*
     
      { return exp;}
}

Expression MinusTerm() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{          
     (exp =AddTerm() ) (  <MINUS>  cur = Expression()
     {exp = new Minus(exp,cur);})*
     
      { return exp;}
}

Expression AddTerm() :{Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{

     
         (exp =MultTerm() ) (  <ADD>  cur = Expression()
     {exp = new Plus(exp,cur);})*
     
      { return exp;}
}

Expression MultTerm() :{Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{
       (exp =DotTerm() ) (  <MULT>  cur = Expression()
     {exp = new Times(exp,cur);})*
     
      { return exp;}
     

}

Expression DotTerm() : {Expression exp;Expression cur = null; ArrayList<Expression> exps =new ArrayList<Expression>(); }
{

	   (exp =ArrayTerm() ) (  <DOT>  cur = DotRHS(exp) 

     {exp = cur;})*
     
      { return exp;}
     
}

Expression DotRHS(Expression lhs ) : {Expression arg;ArrayList<Expression> args = new ArrayList<Expression>();}
{
	(<LENGTH>{return new ArrayLength(lhs);})//note: this may mean that our grammar does not allow identifiers to be named "length"
|({Token id;}	id=<IDENTIFIER> <LPAREN> (
 (arg= Expression() {args.add(arg);}) ( <COMMA> (arg = Expression() {args.add(arg);} ))* )? <RPAREN>
   { return new Call(lhs,id.image,new NodeList<Expression>(args));}
 )
}

Expression ArrayTerm() : { }
{
    {Expression term; Expression index = null;}
	term =TerminalExp() ( <LBRACK>  index=Expression() <RBRACK> )?
	{if(index!=null)
	   return new ArrayLookup(term,index);
	  else
	   return term;	
	}

}

Expression TerminalExp() : {Token id; Expression term; }
{
	(id = <INT_LITERAL> {return new IntegerLiteral(String.valueOf(id.image));})
| ( id= <IDENTIFIER> {return new IdentifierExp(id.image);})
|   <NEW> (term = NewRHS() {return term;})
|   <BANG> (term = Expression() {return new Not(term);})
|   (<LPAREN>( term = Expression() ) <RPAREN>{return term;})
|  ( <THIS> {return new This();})
|   (<TRUE>{return new BooleanLiteral(true);})
|  ( <FALSE>{return new BooleanLiteral(false);})
}

Expression NewRHS() : { }
{
 	({Expression exp;} <INT> <LBRACK> (exp = Expression()) <RBRACK> {return new NewArray(exp);})

 | ( {Token id;}(id = <IDENTIFIER>) <LPAREN> <RPAREN>{return new NewObject(id.image);})
}


